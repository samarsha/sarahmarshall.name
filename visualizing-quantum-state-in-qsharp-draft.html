<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Visualizing Quantum State in Q# | Sarah Marshall</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Visualizing Quantum State in Q#" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="When you want to look at the quantum state of a Q# program, the easiest way is to use DumpMachine or DumpRegister. These functions show you a little table like this on the console: # wave function for qubits with ids (least to most significant): 4;5;6 |0?: 0.098409 + -0.025128 i == * [ 0.010316 ] \+ [ -0.25000 rad ] |1?: 0.165898 + -0.042361 i == * [ 0.029316 ] \+ [ -0.25000 rad ] |2?: 0.335400 + -0.085642 i == *** [ 0.119828 ] \+ [ -0.25000 rad ] |3?: 0.565417 + -0.144375 i == ******* [ 0.340540 ] \+ [ -0.25000 rad ] |4?: 0.098409 + 0.025128 i == * [ 0.010316 ] /- [ 0.25000 rad ] |5?: 0.165898 + 0.042361 i == * [ 0.029316 ] /- [ 0.25000 rad ] |6?: 0.335400 + 0.085642 i == *** [ 0.119828 ] /- [ 0.25000 rad ] |7?: 0.565417 + 0.144375 i == ******* [ 0.340540 ] /- [ 0.25000 rad ] This table is nice. It has all the information you could want to know about the state vector, and it’s easy to add a call to DumpMachine anywhere you want to know what the quantum state is at some particular point in your program. But it’s not especially convenient if you want to see how the state changes over time. You would end up with a bunch of separate tables printed out on the console and have to stitch them together on your own. Plus, it would be nice to have a more visually appealing way of showing the state vector that isn’t limited to console graphics. Let’s take this idea—printing a snapshot of the quantum state at specific points—and run with it. We can call DumpMachine continuously, after every step, and animate the transitions between states. We can remember all of the previous states and show them in a timeline so you can jump back and forth, making it easy to compare the quantum state at any two points in time. This is what the Q# State Visualizer, one of the samples in the in the Microsoft Quantum Development Kit samples repository, does. I worked on it over the summer as part of my internship at Microsoft. This post doubles as a quick guide to how to use the state visualizer and an explanation of how it works. Setting up the visualizer The first step is to clone the QDK samples repository and go to the samples/runtime/state-visualizer folder. There’s a README there that will tell you what you need to do to get started, but the gist of it is that the state visualizer is a web app, so you need Node.js to build the front-end and .NET Core SDK to run the back-end. Once you have the visualizer open in your web browser, you’re done with setup! Using the visualizer The visualizer comes with an example that runs a quantum teleportation circuit followed by Grover’s search algorithm, so you can get started right away without having to use your own Q# program. But you can also run your own code by changing the Program.qs file to whatever you want—just restart the visualizer to run the new code! Here’s an overview of the visualizer’s features. 1. Navigation The buttons at the top of the screen are similar to what you would see in a debugger: you can either step in to the current operation and go through all of its calls to other operations one-by-one, or you can choose to step over them and skip straight to the operation that will run after the current operation finishes. There’s also one button that you don’t usually see in debuggers: a button that lets you go back to the previous operation so you can look at what the quantum state used to be. 2. Timeline The timeline on the left side shows all of the operations that have finished, are currently running, or are about to start. The lists are nested so operations that are called by another operation are shown as indented below the parent operation. The blue arrow points to the operation that’s going to run next. When an operation returns something other than unit, the return value is shown after an equals sign. A neat feature of the timeline is that you can click on any operation in it to jump directly to the quantum state at that point in the program. This makes it really easy to see directly the differences in the quantum state between any two points in time. For technical reasons that I’ll explain in the next section, the timeline only shows Q# operations, not functions. 3. Quantum state The largest part of the screen is taken up by the quantum state itself. It’s a bar chart that shows the amplitude of each basis vector in increasing order from left to right—the basis vector labels are on the bottom. (Unlike DumpMachine, which has bars that show probability instead of probability amplitude, these bars can be negative, so the vertical axis ranges from -1 to +1.) The real parts of the amplitude are shown in red, and the imaginary parts in blue. (The examples here happen to only have real amplitudes, so there are only red bars.) You can also mouse over a bar to see the its precise decimal value instead of relying on the tick marks. Behind the scenes So how does the state visualizer work? The Q# quantum simulator has several events that can be used to track the execution of a Q# program: OnOperationStart, OnOperationEnd, OnAllocateQubits, OnBorrowQubits, OnReleaseQubits, and OnReturnQubits. So the state visualizer runs a program using the quantum simulator, like you would normally, but with event handlers that wait for these events to happen. When they do, the event is sent to the web client along with a snapshot of the quantum state (made using the StateDumper class), which the client then displays in the browser. A consequence of relying on the quantum simulator for events is that the state visualizer has no knowledge of finer-grained information that you might expect from a full-fledged debugger, like which functions are being called, which line of code is being executed, or non-quantum state like the values of local variables. Future steps There are a couple directions you could go in to make the state visualizer better. The UI has some room for improvement. I can think of a few small changes that would be nice to have, like making the timeline resizable, or being able to collapse operations with children in the timeline. There could also be more options for how the quantum state is displayed, like showing probabilities instead of probability amplitudes, or even other kinds of visualizations besides a bar chart. The current visualization also uses color to distinguish between the real and imaginary parts, which may be an issue for colorblind users. It would also be cool to add more debugger-like features to the visualizer (like the ones I mentioned in the previous section that aren’t possible with the current design). Instead of making the web app more like a debugger, it might be better to make Q# debuggers for existing IDEs that include state visualization. As always, feel free to fork the QDK samples repository and submit pull requests for the state visualizer if you’ve made any improvements! This post is part of the 2019 Q# Advent Calendar." />
<meta property="og:description" content="When you want to look at the quantum state of a Q# program, the easiest way is to use DumpMachine or DumpRegister. These functions show you a little table like this on the console: # wave function for qubits with ids (least to most significant): 4;5;6 |0?: 0.098409 + -0.025128 i == * [ 0.010316 ] \+ [ -0.25000 rad ] |1?: 0.165898 + -0.042361 i == * [ 0.029316 ] \+ [ -0.25000 rad ] |2?: 0.335400 + -0.085642 i == *** [ 0.119828 ] \+ [ -0.25000 rad ] |3?: 0.565417 + -0.144375 i == ******* [ 0.340540 ] \+ [ -0.25000 rad ] |4?: 0.098409 + 0.025128 i == * [ 0.010316 ] /- [ 0.25000 rad ] |5?: 0.165898 + 0.042361 i == * [ 0.029316 ] /- [ 0.25000 rad ] |6?: 0.335400 + 0.085642 i == *** [ 0.119828 ] /- [ 0.25000 rad ] |7?: 0.565417 + 0.144375 i == ******* [ 0.340540 ] /- [ 0.25000 rad ] This table is nice. It has all the information you could want to know about the state vector, and it’s easy to add a call to DumpMachine anywhere you want to know what the quantum state is at some particular point in your program. But it’s not especially convenient if you want to see how the state changes over time. You would end up with a bunch of separate tables printed out on the console and have to stitch them together on your own. Plus, it would be nice to have a more visually appealing way of showing the state vector that isn’t limited to console graphics. Let’s take this idea—printing a snapshot of the quantum state at specific points—and run with it. We can call DumpMachine continuously, after every step, and animate the transitions between states. We can remember all of the previous states and show them in a timeline so you can jump back and forth, making it easy to compare the quantum state at any two points in time. This is what the Q# State Visualizer, one of the samples in the in the Microsoft Quantum Development Kit samples repository, does. I worked on it over the summer as part of my internship at Microsoft. This post doubles as a quick guide to how to use the state visualizer and an explanation of how it works. Setting up the visualizer The first step is to clone the QDK samples repository and go to the samples/runtime/state-visualizer folder. There’s a README there that will tell you what you need to do to get started, but the gist of it is that the state visualizer is a web app, so you need Node.js to build the front-end and .NET Core SDK to run the back-end. Once you have the visualizer open in your web browser, you’re done with setup! Using the visualizer The visualizer comes with an example that runs a quantum teleportation circuit followed by Grover’s search algorithm, so you can get started right away without having to use your own Q# program. But you can also run your own code by changing the Program.qs file to whatever you want—just restart the visualizer to run the new code! Here’s an overview of the visualizer’s features. 1. Navigation The buttons at the top of the screen are similar to what you would see in a debugger: you can either step in to the current operation and go through all of its calls to other operations one-by-one, or you can choose to step over them and skip straight to the operation that will run after the current operation finishes. There’s also one button that you don’t usually see in debuggers: a button that lets you go back to the previous operation so you can look at what the quantum state used to be. 2. Timeline The timeline on the left side shows all of the operations that have finished, are currently running, or are about to start. The lists are nested so operations that are called by another operation are shown as indented below the parent operation. The blue arrow points to the operation that’s going to run next. When an operation returns something other than unit, the return value is shown after an equals sign. A neat feature of the timeline is that you can click on any operation in it to jump directly to the quantum state at that point in the program. This makes it really easy to see directly the differences in the quantum state between any two points in time. For technical reasons that I’ll explain in the next section, the timeline only shows Q# operations, not functions. 3. Quantum state The largest part of the screen is taken up by the quantum state itself. It’s a bar chart that shows the amplitude of each basis vector in increasing order from left to right—the basis vector labels are on the bottom. (Unlike DumpMachine, which has bars that show probability instead of probability amplitude, these bars can be negative, so the vertical axis ranges from -1 to +1.) The real parts of the amplitude are shown in red, and the imaginary parts in blue. (The examples here happen to only have real amplitudes, so there are only red bars.) You can also mouse over a bar to see the its precise decimal value instead of relying on the tick marks. Behind the scenes So how does the state visualizer work? The Q# quantum simulator has several events that can be used to track the execution of a Q# program: OnOperationStart, OnOperationEnd, OnAllocateQubits, OnBorrowQubits, OnReleaseQubits, and OnReturnQubits. So the state visualizer runs a program using the quantum simulator, like you would normally, but with event handlers that wait for these events to happen. When they do, the event is sent to the web client along with a snapshot of the quantum state (made using the StateDumper class), which the client then displays in the browser. A consequence of relying on the quantum simulator for events is that the state visualizer has no knowledge of finer-grained information that you might expect from a full-fledged debugger, like which functions are being called, which line of code is being executed, or non-quantum state like the values of local variables. Future steps There are a couple directions you could go in to make the state visualizer better. The UI has some room for improvement. I can think of a few small changes that would be nice to have, like making the timeline resizable, or being able to collapse operations with children in the timeline. There could also be more options for how the quantum state is displayed, like showing probabilities instead of probability amplitudes, or even other kinds of visualizations besides a bar chart. The current visualization also uses color to distinguish between the real and imaginary parts, which may be an issue for colorblind users. It would also be cool to add more debugger-like features to the visualizer (like the ones I mentioned in the previous section that aren’t possible with the current design). Instead of making the web app more like a debugger, it might be better to make Q# debuggers for existing IDEs that include state visualization. As always, feel free to fork the QDK samples repository and submit pull requests for the state visualizer if you’ve made any improvements! This post is part of the 2019 Q# Advent Calendar." />
<link rel="canonical" href="/blog/visualizing-quantum-state-in-qsharp.html" />
<meta property="og:url" content="/blog/visualizing-quantum-state-in-qsharp.html" />
<meta property="og:site_name" content="Sarah Marshall" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-12-15T22:31:15-08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/blog/visualizing-quantum-state-in-qsharp.html","headline":"Visualizing Quantum State in Q#","dateModified":"2019-12-15T22:31:15-08:00","datePublished":"2019-12-15T22:31:15-08:00","description":"When you want to look at the quantum state of a Q# program, the easiest way is to use DumpMachine or DumpRegister. These functions show you a little table like this on the console: # wave function for qubits with ids (least to most significant): 4;5;6 |0?: 0.098409 + -0.025128 i == * [ 0.010316 ] \\+ [ -0.25000 rad ] |1?: 0.165898 + -0.042361 i == * [ 0.029316 ] \\+ [ -0.25000 rad ] |2?: 0.335400 + -0.085642 i == *** [ 0.119828 ] \\+ [ -0.25000 rad ] |3?: 0.565417 + -0.144375 i == ******* [ 0.340540 ] \\+ [ -0.25000 rad ] |4?: 0.098409 + 0.025128 i == * [ 0.010316 ] /- [ 0.25000 rad ] |5?: 0.165898 + 0.042361 i == * [ 0.029316 ] /- [ 0.25000 rad ] |6?: 0.335400 + 0.085642 i == *** [ 0.119828 ] /- [ 0.25000 rad ] |7?: 0.565417 + 0.144375 i == ******* [ 0.340540 ] /- [ 0.25000 rad ] This table is nice. It has all the information you could want to know about the state vector, and it’s easy to add a call to DumpMachine anywhere you want to know what the quantum state is at some particular point in your program. But it’s not especially convenient if you want to see how the state changes over time. You would end up with a bunch of separate tables printed out on the console and have to stitch them together on your own. Plus, it would be nice to have a more visually appealing way of showing the state vector that isn’t limited to console graphics. Let’s take this idea—printing a snapshot of the quantum state at specific points—and run with it. We can call DumpMachine continuously, after every step, and animate the transitions between states. We can remember all of the previous states and show them in a timeline so you can jump back and forth, making it easy to compare the quantum state at any two points in time. This is what the Q# State Visualizer, one of the samples in the in the Microsoft Quantum Development Kit samples repository, does. I worked on it over the summer as part of my internship at Microsoft. This post doubles as a quick guide to how to use the state visualizer and an explanation of how it works. Setting up the visualizer The first step is to clone the QDK samples repository and go to the samples/runtime/state-visualizer folder. There’s a README there that will tell you what you need to do to get started, but the gist of it is that the state visualizer is a web app, so you need Node.js to build the front-end and .NET Core SDK to run the back-end. Once you have the visualizer open in your web browser, you’re done with setup! Using the visualizer The visualizer comes with an example that runs a quantum teleportation circuit followed by Grover’s search algorithm, so you can get started right away without having to use your own Q# program. But you can also run your own code by changing the Program.qs file to whatever you want—just restart the visualizer to run the new code! Here’s an overview of the visualizer’s features. 1. Navigation The buttons at the top of the screen are similar to what you would see in a debugger: you can either step in to the current operation and go through all of its calls to other operations one-by-one, or you can choose to step over them and skip straight to the operation that will run after the current operation finishes. There’s also one button that you don’t usually see in debuggers: a button that lets you go back to the previous operation so you can look at what the quantum state used to be. 2. Timeline The timeline on the left side shows all of the operations that have finished, are currently running, or are about to start. The lists are nested so operations that are called by another operation are shown as indented below the parent operation. The blue arrow points to the operation that’s going to run next. When an operation returns something other than unit, the return value is shown after an equals sign. A neat feature of the timeline is that you can click on any operation in it to jump directly to the quantum state at that point in the program. This makes it really easy to see directly the differences in the quantum state between any two points in time. For technical reasons that I’ll explain in the next section, the timeline only shows Q# operations, not functions. 3. Quantum state The largest part of the screen is taken up by the quantum state itself. It’s a bar chart that shows the amplitude of each basis vector in increasing order from left to right—the basis vector labels are on the bottom. (Unlike DumpMachine, which has bars that show probability instead of probability amplitude, these bars can be negative, so the vertical axis ranges from -1 to +1.) The real parts of the amplitude are shown in red, and the imaginary parts in blue. (The examples here happen to only have real amplitudes, so there are only red bars.) You can also mouse over a bar to see the its precise decimal value instead of relying on the tick marks. Behind the scenes So how does the state visualizer work? The Q# quantum simulator has several events that can be used to track the execution of a Q# program: OnOperationStart, OnOperationEnd, OnAllocateQubits, OnBorrowQubits, OnReleaseQubits, and OnReturnQubits. So the state visualizer runs a program using the quantum simulator, like you would normally, but with event handlers that wait for these events to happen. When they do, the event is sent to the web client along with a snapshot of the quantum state (made using the StateDumper class), which the client then displays in the browser. A consequence of relying on the quantum simulator for events is that the state visualizer has no knowledge of finer-grained information that you might expect from a full-fledged debugger, like which functions are being called, which line of code is being executed, or non-quantum state like the values of local variables. Future steps There are a couple directions you could go in to make the state visualizer better. The UI has some room for improvement. I can think of a few small changes that would be nice to have, like making the timeline resizable, or being able to collapse operations with children in the timeline. There could also be more options for how the quantum state is displayed, like showing probabilities instead of probability amplitudes, or even other kinds of visualizations besides a bar chart. The current visualization also uses color to distinguish between the real and imaginary parts, which may be an issue for colorblind users. It would also be cool to add more debugger-like features to the visualizer (like the ones I mentioned in the previous section that aren’t possible with the current design). Instead of making the web app more like a debugger, it might be better to make Q# debuggers for existing IDEs that include state visualization. As always, feel free to fork the QDK samples repository and submit pull requests for the state visualizer if you’ve made any improvements! This post is part of the 2019 Q# Advent Calendar.","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/visualizing-quantum-state-in-qsharp.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Sarah Marshall" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Sarah Marshall</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Visualizing Quantum State in Q#</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-12-15T22:31:15-08:00" itemprop="datePublished">Dec 15, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>When you want to look at the quantum state of a Q# program, the easiest way is
to use <a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.diagnostics.dumpmachine?view=qsharp-preview"><code class="highlighter-rouge">DumpMachine</code></a> or <a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.diagnostics.dumpregister?view=qsharp-preview"><code class="highlighter-rouge">DumpRegister</code></a>. These functions show you a little
table like this on the console:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># wave function for qubits with ids (least to most significant): 4;5;6
 |0?:    0.098409 + -0.025128 i  ==     *                    [ 0.010316 ]      \+ [ -0.25000 rad ]
 |1?:    0.165898 + -0.042361 i  ==     *                    [ 0.029316 ]      \+ [ -0.25000 rad ]
 |2?:    0.335400 + -0.085642 i  ==     ***                  [ 0.119828 ]      \+ [ -0.25000 rad ]
 |3?:    0.565417 + -0.144375 i  ==     *******              [ 0.340540 ]      \+ [ -0.25000 rad ]
 |4?:    0.098409 +  0.025128 i  ==     *                    [ 0.010316 ]      /- [  0.25000 rad ]
 |5?:    0.165898 +  0.042361 i  ==     *                    [ 0.029316 ]      /- [  0.25000 rad ]
 |6?:    0.335400 +  0.085642 i  ==     ***                  [ 0.119828 ]      /- [  0.25000 rad ]
 |7?:    0.565417 +  0.144375 i  ==     *******              [ 0.340540 ]      /- [  0.25000 rad ]
</code></pre></div></div>

<p>This table is nice. It has all the information you could want to know about the
state vector, and it’s easy to add a call to <code class="highlighter-rouge">DumpMachine</code> anywhere you want to
know what the quantum state is at some particular point in your program. But
it’s not especially convenient if you want to see how the state changes over
time. You would end up with a bunch of separate tables printed out on the
console and have to stitch them together on your own. Plus, it would be nice to
have a more visually appealing way of showing the state vector that isn’t
limited to console graphics.</p>

<p>Let’s take this idea—printing a snapshot of the quantum state at specific
points—and run with it. We can call <code class="highlighter-rouge">DumpMachine</code> continuously, after every
step, and animate the transitions between states. We can remember all of the
previous states and show them in a timeline so you can jump back and forth,
making it easy to compare the quantum state at any two points in time.</p>

<p><img src="/assets/state-visualizer/demo.gif" alt="Animated demo of the state visualizer" /></p>

<p>This is what the <a href="https://github.com/microsoft/Quantum/tree/master/samples/runtime/state-visualizer">Q# State Visualizer</a>, one of the samples in the in the
<a href="https://github.com/microsoft/Quantum">Microsoft Quantum Development Kit samples</a> repository, does. I
worked on it over the summer as part of my internship at Microsoft. This post
doubles as a quick guide to how to use the state visualizer and an explanation
of how it works.</p>

<h2 id="setting-up-the-visualizer">Setting up the visualizer</h2>

<p>The first step is to clone the <a href="https://github.com/microsoft/Quantum">QDK samples</a> repository and go to the
<code class="highlighter-rouge">samples/runtime/state-visualizer</code> folder. There’s a <a href="https://github.com/microsoft/Quantum/blob/master/samples/runtime/state-visualizer/README.md">README</a> there that will
tell you what you need to do to get started, but the gist of it is that the
state visualizer is a web app, so you need <a href="https://nodejs.org/en/">Node.js</a> to build the front-end and
<a href="https://dotnet.microsoft.com/download">.NET Core SDK</a> to run the back-end. Once you have the visualizer open in your
web browser, you’re done with setup!</p>

<h2 id="using-the-visualizer">Using the visualizer</h2>

<p>The visualizer comes with an example that runs a quantum teleportation circuit
followed by Grover’s search algorithm, so you can get started right away without
having to use your own Q# program. But you can also run your own code by
changing the <code class="highlighter-rouge">Program.qs</code> file to whatever you want—just restart the visualizer
to run the new code!</p>

<p>Here’s an overview of the visualizer’s features.</p>

<p><img src="/assets/state-visualizer/overview.png" alt="Numbered sections in the state visualizer's UI" /></p>

<h3 id="1-navigation">1. Navigation</h3>

<p>The buttons at the top of the screen are similar to what you would see in a
debugger: you can either <em>step in</em> to the current operation and go through all
of its calls to other operations one-by-one, or you can choose to <em>step over</em>
them and skip straight to the operation that will run after the current
operation finishes.</p>

<p>There’s also one button that you don’t usually see in debuggers: a button that
lets you go back to the <em>previous</em> operation so you can look at what the quantum
state used to be.</p>

<h3 id="2-timeline">2. Timeline</h3>

<p style="display: inline-block"><img src="/assets/state-visualizer/timeline.png" alt="Timeline in the state visualizer" width="50%" height="50%" /></p>

<p>The timeline on the left side shows all of the operations that have finished,
are currently running, or are about to start. The lists are nested so operations
that are called by another operation are shown as indented below the parent
operation. The blue arrow points to the operation that’s going to run next. When
an operation returns something other than unit, the return value is shown after
an equals sign.</p>

<p>A neat feature of the timeline is that you can click on any operation in it to
jump directly to the quantum state at that point in the program. This makes it
really easy to see directly the differences in the quantum state between any two
points in time.</p>

<p>For technical reasons that I’ll explain in the next section, the timeline only
shows Q# <a href="https://docs.microsoft.com/en-us/quantum/language/type-model?view=qsharp-preview#operation-and-function-types"><em>operations</em>, not functions</a>.</p>

<h3 id="3-quantum-state">3. Quantum state</h3>

<p>The largest part of the screen is taken up by the quantum state itself. It’s a
bar chart that shows the amplitude of each basis vector in increasing order from
left to right—the basis vector labels are on the bottom. (Unlike
<code class="highlighter-rouge">DumpMachine</code>, which has bars that show <em>probability</em> instead of probability
amplitude, these bars can be negative, so the vertical axis ranges from -1 to
+1.) The real parts of the amplitude are shown in red, and the imaginary parts
in blue. (The examples here happen to only have real amplitudes, so there are
only red bars.) You can also mouse over a bar to see the its precise decimal
value instead of relying on the tick marks.</p>

<h2 id="behind-the-scenes">Behind the scenes</h2>

<p>So how does the state visualizer work?</p>

<p>The <a href="https://github.com/microsoft/qsharp-runtime/blob/master/src/Simulation/Common/SimulatorBase.cs">Q# quantum simulator</a> has several events that can be used
to track the execution of a Q# program: <code class="highlighter-rouge">OnOperationStart</code>, <code class="highlighter-rouge">OnOperationEnd</code>,
<code class="highlighter-rouge">OnAllocateQubits</code>, <code class="highlighter-rouge">OnBorrowQubits</code>, <code class="highlighter-rouge">OnReleaseQubits</code>, and <code class="highlighter-rouge">OnReturnQubits</code>.
So the state visualizer runs a program using the quantum simulator, like you
would normally, but with event handlers that wait for these events to happen.
When they do, the event is sent to the web client along with a snapshot of the
quantum state (made using the <a href="https://github.com/microsoft/qsharp-runtime/blob/master/src/Simulation/Simulators/QuantumSimulator/StateDumper.cs"><code class="highlighter-rouge">StateDumper</code></a> class), which the client then
displays in the browser.</p>

<p>A consequence of relying on the quantum simulator for events is that the state
visualizer has no knowledge of finer-grained information that you might expect
from a full-fledged debugger, like which functions are being called, which line
of code is being executed, or non-quantum state like the values of local
variables.</p>

<h2 id="future-steps">Future steps</h2>

<p>There are a couple directions you could go in to make the state visualizer
better.</p>

<p>The UI has some room for improvement. I can think of a few small changes that
would be nice to have, like making the timeline resizable, or being able to
collapse operations with children in the timeline. There could also be more
options for how the quantum state is displayed, like showing probabilities
instead of probability amplitudes, or even other kinds of visualizations besides
a bar chart. The current visualization also uses color to distinguish between
the real and imaginary parts, which may be an issue for colorblind users.</p>

<p>It would also be cool to add more debugger-like features to the visualizer (like
the ones I mentioned in the previous section that aren’t possible with the
current design). Instead of making the web app more like a debugger, it might be
better to make Q# debuggers for existing IDEs that include state visualization.</p>

<p>As always, feel free to fork the <a href="https://github.com/microsoft/Quantum">QDK samples</a> repository and submit pull
requests for the state visualizer if you’ve made any improvements!</p>

<hr />

<p>This post is part of the <a href="https://devblogs.microsoft.com/qsharp/q-advent-calendar-2019/">2019 Q# Advent Calendar</a>.</p>


  </div><a class="u-url" href="/blog/visualizing-quantum-state-in-qsharp.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Sarah Marshall</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Sarah Marshall</li><li><a class="u-email" href="mailto:marshallsaraha@gmail.com">marshallsaraha@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/marshallsa"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">marshallsa</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Senior studying computer science at the University of Washington</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
